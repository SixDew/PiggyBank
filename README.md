# PiggyBank
## 1. REST-API
Следование данным правилам делает делают API RESTful, потому что они обеспечивают соответствие API принципам REST. В частности, обеспечивают единый интерфейс взаимодействия, отсутствие хранения состояния.
## 2. Валидация входных данных
Использовал FluentValidation
### Почему я выбрал именно этот способ проверки
Он обладает большим функционалом, позволяет определять более комплексные сценарии валидации и более гибок в использовании.
## 3. Асинхронность
Запускаем Apache JMeter и отправляем 500 параллельных запросов:

<img width="1502" height="295" alt="изображение" src="https://github.com/user-attachments/assets/3907624c-b3e2-4c52-8ca0-b43ff3875841" />
Пиковое значение потоков:
<img width="1024" height="132" alt="изображение" src="https://github.com/user-attachments/assets/585d1788-6ae6-47ab-8abb-89361c427b9f" />

Асинхронный I/O в .NET - это механизм выполнения операций ввода вывода, который позволяет не блокировать основной поток. Когда выполнение доходит до await, то поток освобождается до окончания выполнения операции. Программа продолжит работу с той же точки, как только операция будет завершена. Асинхронные операции не создают новый поток на каждое выполнение, поэтому они более эффективны при большом числе запросов, чем многопоточность.
## 4. Потокобезопасные счетчики в памяти
Чтобы избежать гонок, необходимо обеспечить синхронизацию доступа потоков к общим ресурсам. Критическая секция - это секция кода, которая должна выполнятся синхронно, т.е. в момент времени доступ к ней должен иметь только один поток. В ней и происходит изменение ресурсов.
В данном случае я выбрал метод блокировки через Interlocked.Increment, т.к. нам достаточно одной атомарной операции инкремента.
## 6. Транзакции и оптимистическая конкуренция
### Разница
Оптимистичная конкуренция:
1. Используется, когда предполагается, что конфликты возникают редко
2. Не разрешает конфликты, а просто отклоняет операцию, сравнивая версии данных при обновлении
3. Не блокирует транзакции в ожидание

Пессимистичная конкуренция:
1. Используется, когда предполагается, что конфликты возникают часто
2. Блокирует выполнение остальных транзакций при изменении данных
3. Обеспечивает более строгую согласованность, но при этом менее производительна и масштабируема
### Почему у нас оптимистичная
Одновременные операции со счетом происходят редко, также более подходящая для масштабируемого REST API.
## 7. Индексы
Индекс - это структура, которую СУБД использует для ускорения поиска по определенному столбцу/столбцам. В простом варианте индекс представляет собой B-tree, в котором все элементы хранятся в отсортированном порядке, что ускоряет поиск элементов. Т.к. индекс необходимо поддерживать в актуальном состоянии при обновлении данных это замедляет их запись.
При необходимости в частой сортировке по нескольким параметрам или при необходимости обеспечения уникальности по нескольким столбцам нужно использовать составной индекс.
При необходимости индексирования по сложным составным данным, например массивам, нужно использовать сиговый индекс. Он создает обратный индекс, в котором каждый ключ связан со множеством значений.
При необходимости полнотекстового поиска по большим текстовым данным нужно использовать полнотекстовый индекс, т.к. он разбивает и хранит текстовое содержимое как множество слов, что упрощает поиск необходимых значений.





